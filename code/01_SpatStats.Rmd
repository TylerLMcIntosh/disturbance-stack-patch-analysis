Run basic spatial statistics on disturbance stack

Tyler L. McIntosh
CU Boulder CIRES Earth Lab
Last updated: 10/20/23

This script uses the following naming conventions wherever possible:
 lowerCamelCase for variables
 period.separated for functions
 underscore_separated for files

# SET GLOBAL PARAMETERS

```{r}
rm(list=ls()) #Ensure empty workspace if running from beginning

#################################################
#####EVERYTHING HERE SHOULD BE SET MANUALLY######
#################################################

computing <- "local" #Sets computing location and file setup; "cyverse" or "local"
rstudio <- TRUE #Sets whether or not the script is being used in RStudio or not; important for CyVerse processing; TRUE or FALSE
parallelFuture <- TRUE #Sets whether or not parallel computing is used; TRUE or FALSE 
aoiL3Names <- c("Sierra Nevada", "Middle Rockies", "Idaho Batholith","Southern Rockies") #The names of the EPA Level 3 ecoregions of interest, may be any length
edgeDepth <- 200 #in meters
resolution <- 30 #in meters

if(computing == "cyverse" & rstudio) {
  Sys.setenv(PROJ_LIB="/opt/conda/envs/earth-analytics-python/share/proj")
}

```

#Load packages etc

```{r, echo = FALSE, warning = FALSE}
# SETUP ----
## Libraries ----

#Check the required libraries and download if needed
list.of.packages <- c("tidyverse", #Includes ggplot2, dplyr, tidyr, readr, purrr, tibble, stringr, forcats
                      "terra", #New raster data package, documentation pdf here: https://cran.r-project.org/web/packages/terra/terra.pdf
                      "future", "future.apply", "furrr", "doFuture", "progressr", #Futureverse! https://www.futureverse.org/packages-overview.html; https://henrikbengtsson.github.io/course-stanford-futureverse-2023/
                      "sf", #New vector data package
                      #"mapview", #For quick interactive mapping
                      "here", #Relative path best practices
                      "landscapemetrics",  #Fragstats for R
                      "tictoc", #time running of processes
                      "tmap",
                      "purrr",
                      "glue", #easy strings
                      "remotes", #to access github libraries
                      "ggpmisc") #For adding R^2 to plots

#Install all packages that aren't installed yet
install.packages(setdiff(list.of.packages, rownames(installed.packages())))

#Force install raster if on cyverse, since old version is installed
if(computing == "cyverse") {
  install.packages("raster")
}

#Load all packages
invisible(lapply(list.of.packages, library, character.only = TRUE)) #use 'invisible' to prevent output being displayed
#If this line throws an error on cyverse, close R session and re-open

#Install ecoregions package from github if needed, then load package
if(!"ecoregions" %in% rownames(installed.packages())) {
  remotes::install_github("tomroh/ecoregions")
}
library(ecoregions)


## Clean workspace & set up environment ----
here::here() #Check here location
here::i_am("code/01_SpatStats.Rmd")
#OR
#setwd() #Set working directory directly
options(digits = 6) #Set standard decimal print output
options(scipen = 999) #Turn scientific notation on and off (0 = on, 999 = off)
```


# Manage computing & CI vs local

```{r}
#Set cores
nCores <- future::availableCores()
if(nCores > 120) {
  nCores <- 120
}else{
  nCores <- nCores - 1
}

#Start futureverse parallel computing
if(parallelFuture) {
  future::plan("multisession", workers = nCores)
}


# A function to test a function that has been set up to run in either sequence or parallel using the futureverse, depending on what plan() has been set.
#For use in troubleshooting. This function will reset plan() to the state before the function was run
#fun = name of function as a string, e.g. "calculate.class.level.metrics"
#... = all parameters for running fun
test.future.function <- function(fun, ...) {
  
  #Get current plan
  initialPlan <- future::plan()
  
  #Test sequential version
  future::plan("sequential")
  tic(glue::glue('Time to run function {fun} in sequence'))
  sTest <- do.call(fun, list(...))
  toc()
  
  #Test parallel version
  future::plan("multisession", workers = nCores)
  tic(glue::glue('Time to run function {fun} in parallel'))
  pTest <- do.call(fun, list(...))
  toc()
  
  #Check if outputs are identical
  glue("Outputs identical? - {identical(sTest, pTest)}")
  
  #Reset plan to original
  future::plan(initialPlan)
  print(glue::glue("Plan reset"))
  
}


```


# Load data and manage data paths

```{r, echo = FALSE}
#Load data

if(computing == "local") {
  fileLocation <- here::here('data', 'nathan_outputs')

  fireInsects <- terra::rast(here::here(fileLocation, "fire_and_insects2.tif"))
  #fireStack <- terra::rast(here::here(fileLocation, "fire_stack.tif"))
  
  fireStack <- terra::rast(here::here('data', 'derived', 'fire_dist_stack_west.tif'))
  #Load forest
  fMask <- terra::rast(here::here('data', 'raw', 'landfire-bps-derived-forest-mask.tif'))

} else if(computing == "cyverse") {
  fireInsects <- terra::rast("~/data-store/data/iplant/home/shared/earthlab/macrosystems/disturbance-stack-patch-analysis/nathan_outputs/fire_and_insects.tif")
  fireStack <- terra::rast("~/data-store/data/iplant/home/shared/earthlab/macrosystems/disturbance-stack-patch-analysis/derived/fire_dist_stack_west.tif")
  #Load forest
  fMask <- terra::rast(here::here('~/data-store/data/iplant/home/shared/earthlab/macrosystems/disturbance-stack-patch-analysis/raw/landfire-bps-derived-forest-mask.tif'))
}



#Load EPA ecoregion data from ecoregions package
epaL3 <- ecoregions::ContinentalUsEcoregion3 %>% 
  sf::st_transform(terra::crs(fireInsects))
epaL4 <- ecoregions::ContinentalUsEcoregion4 %>% 
  sf::st_transform(terra::crs(fireInsects))

  
#EPA ecoregion distinct name table for joins
nameJoin <- cbind(epaL4$us_l4name, 
                  gsub(" ", "", epaL4$us_l4name),
                  epaL4$us_l3name,
                  gsub(" ", "", epaL4$us_l3name)) %>% 
  `colnames<-`(c('us_l4name', 'us_l4nameclean', 'us_l3name', 'us_l3nameclean')) %>%
  as.data.frame() %>%
  dplyr::distinct() %>%
  dplyr::mutate(us_l4l3name = glue::glue("{us_l4nameclean}{us_l3nameclean}"))

```

# Set the areas of interest

```{r}

#EPA level 3 AOI
aoiL3Interest <- epaL3 %>%
  filter(us_l3name %in% aoiL3Names) %>%
  group_by(us_l3name) %>%
  summarize(geometry = st_union(geometry)) %>%
  mutate(us_l3nameclean = gsub(" ", "", us_l3name))

#EPA level 4 AOI
aoiL4Interest <- epaL4 %>%
  filter(us_l3name %in% aoiL3Names) %>%
  group_by(us_l4name, us_l3name) %>%
  summarize(geometry = st_union(geometry)) %>%
  left_join(nameJoin, join_by(us_l3name, us_l4name))

```

# Create raster sets for AOIs

```{r}

#############NOTE###############
#Took some time to try and parallelize this for future use; turns out that SpatVector & SpatRaster objects don't parallelize well; need to either create the object on the core, or wrap/unwrap the files.



#Function to clip a raster to a vector, ensuring in same projection
#Returns raster in original projection, but clipped and masked to vector
careful.clip <- function(raster, vector) {
  #raster <- terra::unwrap(raster) #If it's a wrapped raster for parallelizing, unwrap
  if (sf::st_crs(vector) != terra::crs(raster)) { #if raster and vector aren't in same projection, change vector to match
    print("Projecting vector")
    vector <- sf::st_transform(vector, terra::crs(raster)) 
  } else {
    print("Vector already in raster CRS")
  }
  print("Clipping")
  r <- terra::crop(raster,
                   vector,
                   mask = TRUE) #crop & mask
  return(r)
}


#Function to clip a raster to a set of polygons (one clip per polygon in set),
#ensuring they are in the same projection
#Namefield indicates the field to use to name the item in the returned list (e.g. "us_l4l3name")
#Returns the set of rasters as a named list 
careful.clip.set <- function(raster, vectors, namefield) {
  splitVec <- split(vectors, f=vectors[[namefield]])
   # if (is(future::plan() ,"sequential")) {
    out <- splitVec |> purrr::map(careful.clip, raster = raster)
  # } else {
  #   out <- splitVec |> furrr::future_map(careful.clip, raster = wrap(raster))
  # }
  return(out)
}

#fireInsectInterestList <- careful.clip.set(fireInsects, aoiL3Interest, us_l3nameclean)

#options(future.globals.onReference = "error")


tic("sequential")
fireInsectTestList <- careful.clip.set(fireInsects, aoiL4Interest[1:2,], "us_l4l3name")
toc()
fireTestList <- careful.clip.set(fireStack, aoiL4Interest[1:2,], "us_l4l3name")

# plan(multisession, workers = nCores)
# 
# tic("parallel")
# fireInsectInterestList2 <- careful.clip.set(fireInsects, aoiL4Interest[1:2,], "us_l4l3name")
# toc()





```


# Perform computations on forest mask layer to get per/forest stats

```{r}


#Clip and mask to EPA L4 areas
forestMaskL4 <- careful.clip.set(fMask, aoiL4Interest[1:2,], "us_l4l3name")


#Get the number of forested pixels
forestL4 <- forestMaskL4 |>
  lapply(FUN = function(x) {global(x, fun = "notNA")})

#Clean up and join together with region name data
forestL4Stats <- cbind(names(forestMaskL4),
                bind_rows(forestL4)) |>
  dplyr::rename(us_l4l3name = `names(forestMaskL4)`) |>
  dplyr::mutate(forestAreaHa = notNA * 900 * .0001) |> #900m^2 / pixel, ha conversion .0001
  dplyr::left_join(nameJoin, by = join_by(us_l4l3name))

#Group stats from L4 to L3
forestL3Stats <- forestL4Stats |>
  dplyr::group_by(us_l3name, us_l3nameclean) |>
  dplyr::summarize(forestAreaHa = sum(forestAreaHa))

#Remove un-needed objects
rm(fMask, forestMaskL4, forestL4)
```

Create csv files with data on landscape metrics for all regions in the AOI, EPA L4 & L3

```{r}

#Set outdirectory
outDirT <- here("data", "derived", "metric_tables")
if (!dir.exists(outDirT)){
  dir.create(outDirT)
}



#Function to run landscapemetrics::calculate_lsm and add the layer names
calculate.lsm.with.names <- function(land, ...) {
  out <- land |>
    landscapemetrics::calculate_lsm(...) |>
    dplyr::mutate(layerName = names(land)[layer])
  return(out)
}


#Function to run the landscapemetrics::calculate_lsm function in parallel environment
parallel.calculate.lsm.with.names <- function(land, ...) {
  out <- land |>
    terra::unwrap() |>
    calculate.lsm.with.names(...)
  return(out)
}

#Function to add additional data to the metrics dataframe
#Script-specific, do not port
add.region.to.metric.df <- function(df, nm) {
  #Add region name & level to dataframe
  out <- df |>
    dplyr::mutate(region = nm,
                  epaLevel = dplyr::case_when(region %in% nameJoin$us_l3nameclean ~ "epaL3",
                                              region %in% nameJoin$us_l4l3name ~ "epaL4"))
  return(out)
}


#Function to calculate class-level metrics, add LSM names, and add contextual data over a named list of landscapes
#This function is set up to run in parallel with the futureverse
calculate.class.level.metrics <- function(landList) {
  if(is(future::plan(), "sequential")) {
    print('Processing in sequence')
      out <- landList |>
        purrr::map(calculate.lsm.with.names, #use version that includes raster layer names in output
                   what = c(
                             'lsm_c_ed', #patch area-weighted edge density
                             'lsm_c_ca', #total class area
                             'lsm_c_ai',
                             'lsm_c_clumpy',
                             'lsm_c_cpland',
                             'lsm_c_dcad',
                             'lsm_c_division',
                             'lsm_c_lpi',
                             'lsm_c_lsi',
                             'lsm_c_mesh',
                             'lsm_c_np',
                             'lsm_c_pafrac',
                             'lsm_c_tca',
                             'lsm_c_cohesion'), #aggregation of patches
                   directions = 8,
                   edge_depth = edgeDepth %/% resolution, #without remainder; edge depth is in cells
                   progress = TRUE,
                   full_name = TRUE)
  } else {
    print('Processing in parallel')
      out <- landList |>
        purrr::map(terra::wrap) |> #wrap each raster to send to node
        furrr::future_map(parallel.calculate.lsm.with.names, #use parallelized version that unwraps first
                   what = c(
                             'lsm_c_ed', #patch area-weighted edge density
                             'lsm_c_ca', #total class area
                             'lsm_c_ai',
                             'lsm_c_clumpy',
                             'lsm_c_cpland',
                             'lsm_c_dcad',
                             'lsm_c_division',
                             'lsm_c_lpi',
                             'lsm_c_lsi',
                             'lsm_c_mesh',
                             'lsm_c_np',
                             'lsm_c_pafrac',
                             'lsm_c_tca',
                             'lsm_c_cohesion'), #aggregation of patches
                   directions = 8,
                   edge_depth = edgeDepth %/% resolution, #without remainder; edge depth is in cells
                   progress = TRUE,
                   full_name = TRUE) 
  }
  out <- out %>%
    purrr::map2(.f = add.region.to.metric.df, .y = names(.)) #Add more data using add.data.to.metric.df function
  return(out)
}

#Function to calculate class-level metrics, add LSM names, and add contextual data over a named list of landscapes
calculate.patch.level.metrics <- function(landList) {
  if(is(future::plan(), "sequential")) {
      out <- landList |>
        purrr::map(landscapemetrics::calculate.lsm.with.names,
                   what = "patch", #all patch metrics
                   directions = 8,
                   edge_depth = edgeDepth %/% resolution, #without remainder; edge depth is in cells
                   progress = TRUE,
                   full_name = TRUE)
  } else {
      out <- landList |>
        purrr::map(terra::wrap) |> #wrap each raster to send to node
        furrr::future_map(parallel.calculate.lsm.with.names, #use parallelized version that unwraps first
                   what = "patch", #all patch metrics
                   directions = 8,
                   edge_depth = edgeDepth %/% resolution, #without remainder; edge depth is in cells
                   progress = TRUE,
                   full_name = TRUE)
  }
  out <- out %>%
    purrr::map2(.f = add.region.to.metric.df, .y = names(.)) #Add more data using add.data.to.metric.df function
  return(out)  
}


#Write out landscape metric CSVs
write.land.metric.csv.w.name <- function(df, nm, dir) {
  nmApp <- glue::glue("_{unique(df$level)}_{unique(df$epaLevel)}_")
  flNm <- glue::glue("{nm}{nmApp}.csv")
  readr::write_csv(df, here::here(dir, flNm))
}



#Create level 4 class metric list
classL4 <- fireInsectTestList |>
  calculate.class.level.metrics()
# #Write out
# classL4 %>%
#   purrr::map2(.f = write.land.metric.csv.w.name, .y = names(.), dir = outDirT)
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# # #Write out landscape metric CSVs
# # write.land.metric.csv.w.name <- function(df, nm, nmApp, dir) {
# #   flNm <- glue::glue("{nm}{nmApp}.csv")
# #   readr::write_csv(df, here::here(dir, flNm))
# # }
# x <- t %>% purrr::map2(.f = add.data.to.metric.df, .y = names(.))
# 
# xx <- tt %>% purrr::map2(.f = add.data.to.metric.df, .y = names(.))
# # xx %>% purrr::map2(.f = write.land.metric.csv.w.name, .y = names(.), nmApp = "_class_", dir = outDirT)



# t <- fireInsectTestList |>
#   purrr::map(landscapemetrics::calculate_lsm,
#              what = c(
#                        'lsm_c_ed', #patch area-weighted edge density
#                        'lsm_c_ai',
#                        'lsm_c_clumpy',
#                        'lsm_c_cpland',
#                        'lsm_c_dcad',
#                        'lsm_c_division',
#                        'lsm_c_lpi',
#                        'lsm_c_lsi',
#                        'lsm_c_mesh',
#                        'lsm_c_np',
#                        'lsm_c_pafrac',
#                        'lsm_c_tca',
#                        'lsm_c_cohesion'), #aggregation of patches
#              directions = 8,
#              progress = TRUE,) |>
#   purrr::map(dplyr::left_join, y = lsm_abbreviations_names,
#                        by = c("metric", "level"))
# 
# tt <- fireTestList |>
#   purrr::map(landscapemetrics::calculate_lsm,
#              what = c(
#                        'lsm_c_ed', #patch area-weighted edge density
#                        'lsm_c_ai',
#                        'lsm_c_clumpy',
#                        'lsm_c_cpland',
#                        'lsm_c_dcad',
#                        'lsm_c_division',
#                        'lsm_c_lpi',
#                        'lsm_c_lsi',
#                        'lsm_c_mesh',
#                        'lsm_c_np',
#                        'lsm_c_pafrac',
#                        'lsm_c_tca',
#                        'lsm_c_cohesion'), #aggregation of patches
#              directions = 8,
#              progress = TRUE,) |>
#   purrr::map(dplyr::left_join, y = lsm_abbreviations_names, #Add full metric names
#                        by = c("metric", "level")) %>%
#   purrr::map2(.f = add.data.to.metric.df, .y = names(.)) #Add more data






```



