Run spatial statistics on disturbance stack, including summaries and patch statistics

Tyler L. McIntosh
CU Boulder CIRES Earth Lab
Last updated: 1/24/24

This script uses the following naming conventions wherever possible:
 lowerCamelCase for variables
 period.separated for functions
 underscore_separated for files


# Setup workspace
User-set global parameters
Directory management
Package management

```{r setup, echo = FALSE, warning = FALSE, message = FALSE}

rm(list=ls()) #Ensure empty workspace if running from beginning

#################################################
#####EVERYTHING HERE SHOULD BE SET MANUALLY######
#################################################

computing <- "local" #Sets computing location and file setup; "cyverse" or "local"
nCores <- 4 #Number of cores available - only necessary if on CyVerse (future package struggles to read automatically on CyVerse, reads 128 (the maximum number of cores)

forestPercCutoff <- 1 #The percentage of forest below which EPA regions will not be retained for calculations
edgeDepth <- 200 #the edge depth to use for all landscapemetrics 'core' caluclations, in meters
resolution <- 30 #of the input rasters, in meters

#################################################

# Directory management ----
require(here)

#Set here location
here::i_am("code/02_regional_disturbance_stats.qmd")

#Set directories
if(computing == "local") {
  home <- here::here()
} else if(computing == "cyverse") {
  home <- "~/data-store/data/iplant/home/shared/earthlab/macrosystems/disturbance-stack-patch-analysis"
}

#Raw data
rawDir <- file.path(home, 'data/raw')

#Nathan outputs directory
natOut <- file.path(home, 'data/nathan_outputs')

#Derived data (outdirectory)
devDir <- file.path(home, 'data/derived')
if (!dir.exists(devDir)){
  dir.create(devDir)
}

#Specific derived data directory for this script's outputs
outDir <- file.path(devDir, "summary_stats")
if (!dir.exists(outDir)){
  dir.create(outDir)
}

# Package management ----

source(here::here('code/functions.R'), local = FALSE)

#Check the required libraries and download if needed
packageList <- c(
  "tidyverse", #Includes ggplot2, dplyr, tidyr, readr, purrr, tibble, stringr, forcats
  "terra", #New raster data package, documentation pdf here: https://cran.r-project.org/web/packages/terra/terra.pdf
  "future", "future.apply", "furrr", "doFuture", "progressr", #Futureverse! https://www.futureverse.org/packages-overview.html; https://henrikbengtsson.github.io/course-stanford-futureverse-2023/
  "sf", #New vector data package
  #"mapview", #For quick interactive mapping
  "tictoc", #time running of processes
  "glue", #easy strings
  "tigris", #state polygons
  "ggpmisc"  #For adding R^2 to plots
)

install.and.load.packages(packageList, autoInstall = "y")

#Start parallel computing ----
#Set cores
if(computing == "local") {
  nCores <- future::availableCores() - 1
} else if(computing == "cyverse") {
  cat("Using user-defined number of computing cores:", nCores)
}
future::plan("multisession", workers = nCores)

```


# Load data paths

```{r load-data, echo = FALSE}

#Load data

#Data from Nathan ----
#Individual disturbance stacks
fireStackF <- file.path(devDir, 'fire_dist_stack_west.tif')
insectStackF <- file.path(devDir, 'insect_dist_stack_west.tif')
droughtStackF <- file.path(devDir, 'drought_dist_stack_west.tif')

#Individual disturbance sums
fireSumsF <- file.path(natOut, 'beetle_stack.tif')
beetleSumsF <- file.path(natOut, 'fire_stack.tif')
droughtSumsF <- file.path(natOut, 'drought_stack.tif')

#Individual disturbance 5yr moving windows
beetle5yrF <- list.files(file.path(natOut), pattern = "beetle_totals", full.names = TRUE)
disturbance5yrF <- list.files(file.path(natOut), pattern = "disturbance_totals", full.names = TRUE)
drought5yrF <- list.files(file.path(natOut), pattern = "drought_totals", full.names = TRUE)
fire5yrF <- list.files(file.path(natOut), pattern = "fire_totals", full.names = TRUE)

#Disturbance combination 5yr moving windows
fireDrought5yrF <- list.files(file.path(natOut, "fire-dought"), pattern = "fire_drought_totals", full.names = TRUE)
fireBeetle5yrF <- list.files(file.path(natOut, "fire-beetle"), pattern = "fire_beetle_totals", full.names = TRUE)
droughtBeetle5yrF <- list.files(file.path(natOut, "drought-beetle"), pattern = "bettle_drought_totals", full.names = TRUE)
#fireBeetleDrought5yrF <- list.files(file.path(natOut, "FILL THIS OUT", pattern = "FILL THIS OUT", full.names = TRUE))

#Additional data
#Load ecoregion & forest data
nameJoin <- readr::read_csv(file.path(devDir, "epal3l4_name_join.csv")) #EPA ecoregion distinct name table for joins (from script 01)
forestL4Stats <- readr::read_csv(file.path(devDir, "forest_l4_dats.csv")) #EPA ecoregion stats on amount of forest (from script 01)
forestL3Stats <- readr::read_csv(file.path(devDir, "forest_l3_dats.csv")) #EPA ecoregion stats on amount of forest (from script 01)
epaL3F <- file.path(rawDir, "us_eco_l3/us_eco_l3.shp")
epaL4F <- file.path(rawDir, "us_eco_l4/us_eco_l4_no_st.shp")

```

# Set the areas of interest based on EPA ecoregions
This code will only use L3 ecoregions with forest over a certain percentage of the landscape (forestPercCutoff)
It will retain and use all L4 ecoregions within the selected L3 ecoregions

```{r}

# #Get the names of regions with enough forest
# l3AboveForestPerc <- forestL3Stats |>
#   dplyr::filter(percForest >= forestPercCutoff) |>
#   dplyr::pull(US_L3NAMECLEAN)
# 
# #EPA level 3 AOI
# aoiL3Interest <- epaL3 |>
#   dplyr::group_by(US_L3NAME) |>
#   dplyr::summarize(geometry = st_union(geometry)) |>
#   dplyr::mutate(US_L3NAMECLEAN = gsub(" ", "", US_L3NAME)) |>
#   dplyr::filter(US_L3NAMECLEAN %in% l3AboveForestPerc)
# 
# #EPA level 4 AOI
# aoiL4Interest <- epaL4 |>
#   dplyr::group_by(US_L4NAME, US_L3NAME) |>
#   dplyr::summarize(geometry = st_union(geometry)) |>
#   dplyr::left_join(nameJoin, join_by(US_L3NAME, US_L4NAME)) |>
#   dplyr::filter(US_L3NAMECLEAN %in% l3AboveForestPerc)

#Two small l4 ecoregions to test script
test <- epaL4 |>
  dplyr::group_by(US_L4NAME, US_L3NAME) |>
  dplyr::summarize(geometry = st_union(geometry)) |>
  dplyr::left_join(nameJoin, join_by(US_L3NAME, US_L4NAME)) |>
  dplyr::filter(US_L4NAME == "Foothill Potholes" | US_L4NAME == "Western Beaverhead Mountains")

# test2 <- epaL4 |>
#   dplyr::group_by(US_L4NAME, US_L3NAME) |>
#   dplyr::summarize(geometry = st_union(geometry)) |>
#   dplyr::left_join(nameJoin, join_by(US_L3NAME, US_L4NAME)) |>
#   dplyr::filter(US_L3NAME == "SouthernRockies")
  
```


# Core function: compute stats
This function performs all operations on a given disturbance stack raster set, calling functions sourced from functions.R

```{r}

#Function to bring all of the above functions together
#This function requires a set name (setNm) as a string, which clarifies what the input raster represents (e.g. "Fire"), and will be used in the output file names
#Output files will be in OutDirT, in the form: "setNm_ecoregion_class/patch_epaLevel.csv"
generate.raster.metrics.for.aoi.set <- function(raster, aoiSet, setNm) {
  if(grepl("_", setNm)) {
    stop("'setNm' cannot contain an underscore")
  }
  #If the aoi set is for epa l4 ecoregions, process appropriately and do both class and patch metrics
  if("US_L4L3NAME" %in% names(aoiSet)) {
    clippedRasterList <- careful.clip.set(raster, aoiSet, "US_L4L3NAME")
    # classMetrics <- clippedRasterList |>
    #    calculate.class.level.metrics()
    # classMetrics %>%
    #    purrr::map2(.f = write.land.metric.csv.w.name, .y = names(.), dir = outDirT, set = setNm)
    patchMetrics <- clippedRasterList |>
       calculate.patch.level.metrics()
    patchMetrics %>%
       purrr::map2(.f = write.land.metric.csv.w.name, .y = names(.), dir = outDirT, set = setNm)
  } else { #If L3, only do class metrics
    clippedRasterList <- careful.clip.set(raster, aoiSet, "US_L3NAMECLEAN")
    # classMetrics <- clippedRasterList |>
    #    calculate.class.level.metrics()
    # classMetrics %>%
    #    purrr::map2(.f = write.land.metric.csv.w.name, .y = names(.), dir = outDirT, set = setNm)
    patchMetrics <- clippedRasterList |>
       calculate.patch.level.metrics()
    patchMetrics %>%
       purrr::map2(.f = write.land.metric.csv.w.name, .y = names(.), dir = outDirT, set = setNm)
  }
  gc()
  # asTbl <- read.set.csvs.as.one(setNm)
  # return(asTbl)
}



```


# Run core function on datasets

```{r}


tic("One-layer raster, parallel")
testOut <- generate.raster.metrics.for.aoi.set(fireInsects, test, setNm = "testSingle")
toc() #15.87 seconds total

tic("Multi-layer raster, parallel")
testOut <- generate.raster.metrics.for.aoi.set(fireStack, test, setNm = "testMulti")
toc() #149 seconds total, 2.5 min



#APPLY OVER 'ALL' object

```



